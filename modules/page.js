"use strict";

const electron = require("electron");
const page_io = require("./page_io");
const marked = require("marked");


const magic_left  = "db73nx91izs7d8egr2gu283a9gh";
const magic_right = "b6x9ahr12fgf20fg2f82f7ofg48";


exports.new_page = function(title, special) {

	return Object.assign(Object.create(page_prototype), {
		title: title,
		special: special ? true : false,
		markdown: null,
	});
	
};

const page_prototype = {

	get_html() {

		let s = this.markdown;

		if (typeof s !== "string") {
			throw new Error("page.markdown was not a string.");
		}

		// Escape some things before the Markdown parser. We have to do this before the
		// Markdown parser, otherwise HTML generated by it becomes indistinguishable from
		// HTML that was present in the input.

		s = s.replace(/&/g, `&amp;`);
		s = s.replace(/</g, `&lt;`);
//		s = s.replace(/>/g, `&gt;`);			// Commented so blockquotes can work.
		s = s.replace(/'/g, `&apos;`);
		s = s.replace(/"/g, `&quot;`);

		// Markdown parser:

		s = marked.parse(s);

		// Deal with some issues caused inside code tags:

		let foo = document.createElement("div");
		foo.innerHTML = s;

		for (let item of foo.getElementsByTagName("code")) {

			// Anything inside a code block will be escaped, but we already escaped some stuff so this leads
			// to some things being escaped twice. Undo this:

			item.innerHTML = item.innerHTML.replace(/&amp;amp;/g, "&amp;");
			item.innerHTML = item.innerHTML.replace(/&amp;lt;/g, "&lt;");
//			item.innerHTML = item.innerHTML.replace(/&amp;gt;/g, "&gt;");			// See above.
			item.innerHTML = item.innerHTML.replace(/&amp;apos;/g, "&apos;");
			item.innerHTML = item.innerHTML.replace(/&amp;quot;/g, "&quot;");
			
			// Obfuscate [[stuff like this]] from <code> tags so it doesn't get turned into internal links later.
			// I can't see a better way to do this than creating a DOM and finding the <code> tags that way:

			item.innerHTML = item.innerHTML.replace(/\[\[(.*?)\]\]/g, `${magic_left}$1${magic_right}`);
		}

		s = foo.innerHTML;			// So after this point, we are once again working on a string, not a DOMish thing.

		// Parse actual internal links:

		s = s.replace(/\[\[(.*?)\]\]/g, `<span class="internal">$1</span>`);

		// Restore [[stuff]] which we obfuscated above:

		let regex = new RegExp(`${magic_left}(.*?)${magic_right}`, "g");

		s = s.replace(regex, `[[$1]]`);

		// Done:

		return s;
	},

	autoload: function() {
		this.markdown = page_io.load(this.title);
	},

	autosave: function() {
		page_io.save(this.title, this.markdown);
	},

	render: function() {

		let everything = "";

		everything += `<h1 class="top"><span id="title">${this.title}</span> ${!this.special ? `[<span id="editbutton">edit</span>]` : ""}</h1>\n`;
		everything += `<hr />`;
		everything += this.get_html();

		document.body.innerHTML = everything;			// Do this first so the getElement lookups below work.

		// ---

		let editbutton = document.getElementById("editbutton");

		if (editbutton) {
			editbutton.addEventListener("click", () => {
				eliki.edit();
			});
		}

		let int_links = document.getElementsByClassName("internal");

		for (let item of int_links) {
			item.addEventListener("click", () => {
				eliki.go(item.innerHTML);
			});
		}

		let ext_links = document.getElementsByTagName("a");

		for (let item of ext_links) {
			item.addEventListener("click", (event) => {
				event.preventDefault();
				electron.shell.openExternal(item.href);
			});
		}

	},

	edit: function() {

		if (this.special) {
			alert("Cannot edit special pages.");
			return;
		}

		let everything = "";

		everything += `<h1 class="top">Editing <span id="title">${this.title}</span></h1>\n`;
		everything += `<button id="savebutton">Save</button> &nbsp; <button id="cancelbutton">Cancel</button><br><br>\n`;
		everything += `<textarea id="editor"></textarea>\n`;

		document.body.innerHTML = everything;						// Do this first so the getElement lookups below work.

		// ---

		let editor = document.getElementById("editor");
		editor.style.height = Math.max(window.innerHeight - editor.getBoundingClientRect().top - 48, 100).toString() + "px";
		editor.value = this.markdown;

		editor.addEventListener("keydown", (event) => {				// This allows the tab key to be used in the textarea.
			if (event.which === 9) {
				event.preventDefault();
				document.execCommand("insertText", false, "\t");
			}
		});

		document.getElementById("savebutton").addEventListener("click", () => {
			this.markdown = document.getElementById("editor").value;
			this.autosave();
			this.render();
		});

		document.getElementById("cancelbutton").addEventListener("click", () => {
			this.render();
		});
	},

};
